package com.estock.batch;

import java.math.BigDecimal;
import java.sql.Timestamp;

import org.springframework.batch.item.ItemProcessor;

import com.estock.model.DataFile;
import com.estock.model.OrderDetailsResponse;
import com.estock.model.Orders;
import com.estock.model.Stock;
import com.estock.repository.OrdersRepository;
import com.estock.repository.StockRepository;

public class OrdersProcessor implements ItemProcessor<DataFile, Orders> {

	private StockRepository stockRepository;

	private OrdersRepository ordersRepository;

	@Override
    public Orders process(DataFile item) throws Exception {
        // Transform DataFile to Orders fields
		Long orderId = Long.parseLong(item.getOrderId());
		String orderCustomer = item.getOrderCustomer();
		Long itemCode = Long.parseLong(item.getItemCode());
		Integer itemSoldQTY = Integer.parseInt(item.getItemSoldQTY());

        // Perform processing on the item
		Orders order = ordersRepository.getOrderDetails(orderId);
		Stock itemDetails = stockRepository.getItemDetails(itemCode);
		Timestamp timestamp = new Timestamp(System.currentTimeMillis());
		  
		if(order == null && itemSoldQTY <= itemDetails.getItemStockQTY()) {
		  //Add new order
		  this.buildOrder(orderId, orderCustomer, itemSoldQTY, itemDetails, "NEW_COMPLETE", null);
		} 
		  
		if(itemSoldQTY > itemDetails.getItemStockQTY()) {
		  //Reject add/update order
		  orderDetails = OrderDetailsResponse.builder()
						.orderId(orderId)
						.orderCustomer(orderCustomer)
						.orderDate(timestamp)
						.itemCode(itemCode)
						.itemName(stockRepository.getItemName(itemCode))
						.itemSoldQTY(itemSoldQTY)
						.itemPrice(itemDetails.getItemPrice())
						.orderTotalAmount(itemDetails.getItemPrice().multiply(BigDecimal.valueOf(itemSoldQTY)))
						.orderStatus(order==null?"NEW_FAIL":"CHANGE_FAIL")
						.orderComment("Unsufficient stock quantity")
						.build();
		  }
		  
		  if(order != null && order.getItemSoldQTY() + itemSoldQTY < 0) {
			//Reject update order
			Integer newSoldQTY = order.getItemSoldQTY() + itemSoldQTY;
			orderDetails = OrderDetailsResponse.builder()
						.orderId(orderId)
						.orderCustomer(orderCustomer)
						.orderDate(timestamp)
						.itemCode(itemCode)
						.itemName(stockRepository.getItemName(itemCode))
						.itemSoldQTY(newSoldQTY)
						.itemPrice(itemDetails.getItemPrice())
						.orderTotalAmount(itemDetails.getItemPrice().multiply(BigDecimal.valueOf(newSoldQTY)))
						.orderStatus("RETURN_FAIL")
						.orderComment("Invalid return quantity")
						.build();
		  }
		  
		  if(order != null && order.getItemSoldQTY() + itemSoldQTY >= 0) {
			//Update order
			this.updateOrder(orderId, itemSoldQTY, itemDetails);
			orderDetails = this.getOrderDetails(orderId);
		  }

		  
    	// Create a ProcessedData object with processed values
        return new Orders(/* processed data */);
    }
    
	private Orders buildOrder(
			Long orderId, 
			String orderCustomer, 
			Integer itemSoldQTY, 
			Stock itemDetails,
			String orderStatus,
			String orderComment) {
		
		Timestamp timestamp = new Timestamp(System.currentTimeMillis());
		BigDecimal orderTotalAmount = itemDetails.getItemPrice().multiply(BigDecimal.valueOf(itemSoldQTY));
		Timestamp orderDate, updateDate = null;
		if(orderStatus.contains("NEW")) {
			orderDate = timestamp;
			updateDate = null;
		} else {
			orderDate = ordersRepository.getOrderDetails(orderId).getOrderDate();
			updateDate = timestamp;			
		}
		
		Orders order = Orders.builder()
					.orderId(orderId)
					.orderCustomer(orderCustomer)
					.orderDate(orderDate)
					.updateDate(updateDate)
					.itemCode(itemDetails.getItemCode())
					.itemSoldQTY(itemSoldQTY)
					.itemPrice(itemDetails.getItemPrice())
					.orderTotalAmount(orderTotalAmount)
					.orderStatus(orderStatus)
					.orderComment(orderComment)
					.build();
		
		return order;
	}
	
}
